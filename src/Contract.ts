import { BlockNumber } from 'web3-core';
import { Contract as IWeb3Contract, ContractSendMethod as Web3Method } from 'web3-eth-contract';
import Web3Utils from 'web3-utils';
import Web3 from 'web3';

import Big from './types/big';
import ITx from './types/ITx';

/* eslint-disable @typescript-eslint/no-var-requires */
const AbiCoder = require('web3-eth-abi');
const Web3Contract = require('web3-eth-contract');
/* eslint-enable @typescript-eslint/no-var-requires */

type IWeb3Response = { [key: string]: any };
export type AsyncCaller<T> = (provider: Web3, block?: BlockNumber) => Promise<T>;

/**
 * The ordinary `web3.eth.Contract(...)` implementation uses `web3.currentProvider`
 * to make blockchain calls and sends convenient. This class extricates the notion
 * of a Provider from that of a Contract, allowing contracts to be instantiated
 * at any point in the code -- no need to first setup a web3 provider.
 *
 * That said, the ordinary `web3.eth.Contract(...)` should be used when subscribing
 * to events and/or retrieving past events because the API is clear and will notify
 * listeners if an on-chain event was rolled back by a chain fork.
 */
export default class Contract {
  public readonly address: string;

  protected readonly abi: Web3Utils.AbiItem[];

  protected readonly inner: IWeb3Contract;

  /**
   * Constructs a new Contract instance
   *
   * @param address the address (0x123abc...) of the deployed contract
   * @param abi the abi of the deployed contract, generated by compiler
   */
  constructor(address: string, abi: Web3Utils.AbiItem[]) {
    this.address = address;
    this.abi = abi;
    this.inner = new Web3Contract(abi, address);
  }

  /**
   * Returns an async function that can fetch return data from any Solidity `method`
   * whose return type is uint256
   *
   * @param method the Solidity method to call (with input params)
   */
  protected callerForUint256(method: Web3Method): AsyncCaller<Big> {
    return this.callerFor<Big>(method, ['uint256'], (x) => Big(x['0']));
  }

  /**
   * Returns an async function that can fetch return data from any Solidity `method`
   *
   * @param method the Solidity method to call (with input params)
   * @param outputTypes array of Solidity return types, e.g. 'uint256'
   * @param modifier function that applies post-processing after fetching
   */
  protected callerFor<T>(method: Web3Method, outputTypes: string[], modifier: (x: IWeb3Response) => T): AsyncCaller<T> {
    return async (provider: Web3, block: BlockNumber = 'latest') => {
      const x = await provider.eth.call(
        {
          to: this.address,
          data: method.encodeABI(),
        },
        block,
      );
      return modifier(AbiCoder.decodeParameters(outputTypes, x));
    };
  }

  /**
   * Returns a sendable transaction object that will call `method`
   *
   * @param method the Solidity method that you want to run on-chain
   * @param gasLimit maximum gas to spend running the method
   * @param gasPrice Wei to spend per gas unit
   */
  protected txFor(method: Web3Method, gasLimit = Big('0'), gasPrice = Big('0')): ITx {
    return {
      gasPrice,
      gasLimit,
      to: this.address,
      data: method.encodeABI(),
    };
  }

  protected storageAt<T>(slot: string, modifier: (x: string) => T): AsyncCaller<T> {
    return async (provider: Web3, block = 'latest') => {
      const x = await provider.eth.getStorageAt(this.address, slot, block);
      return modifier(x);
    };
  }
}
